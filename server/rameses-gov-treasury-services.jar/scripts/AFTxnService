import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.services.extended.*;

/********************************************************************************************************************
* Notes: 
* ACTION	    TXNTYPES														DESCRIPTION
* ------		--------														-----------
* addBatch      RECEIPT,BEGIN_BALANCE and FORWARD
* editBatch     FORWARD (current series), ISSUE (for cashtickets - endseries)
* issue   		ISSUE
* move			RETURN, TRANSFER
********************************************************************************************************************/

class AFTxnService  {

	@DataContext("af_control")
	def afControl;

	@DataContext("af_control_detail")
	def afControlDetail;

	@DataContext("aftxn")
	def aftxn;

	@DataContext("aftxnitem")
	def aftxnItem;

	@DataContext("af_allocation")
	def afAlloc;

	@Service("DateService")
	def dateSvc;

	@Service("AFInventoryService")
	def afInvSvc;

	@Service("PersistenceService")
	def persistSvc;

	@Env
	def env;


	/****************************************************************************
	* must only pass the ff:
	* aftxnitemid, qty, startseries, endseries, startstub, endstub, prefix, suffix
	*****************************************************************************/
	@ProxyMethod
	public void addBatch( def o ) { 
		def txndate = dateSvc.getServerDate();
		def afi = aftxnItem.find([objid: o.aftxnitemid] ).select("objid,item.objid,unit,qtyserved,qty,txntype,cost,parent.*,afunit.*").first();

		if( (afi.qtyserved + o.qty) > afi.qty )
			throw new Exception("qty specified must not exceed the unserved qty");

		//find first if there is already a previous batch
		def  z = afControlDetail.select( "batchno:{MAX( parent.batchno )}" ).find( [ aftxnitemid: o.aftxnitemid ] ).groupBy( "aftxnitemid" ).first();

		int batchno = 1;
		if( z ) {
			batchno = z.batchno + 1;
		}
		
		def afunit = afi.afunit;

		int interval = (!afunit.interval) ? 1 : afunit.interval;
		int len = (afunit.serieslength ? afunit.serieslength : 10);	
		int stubno = o.startstub; 
 		int starter = (o.startseries ? Integer.parseInt( o.startseries ) : 0);
		(1..o.qty).each { 
			def afc = [:];
			afc.afid = afi.item.objid;
			afc.unit = afi.unit;

			afc.afunit = afi.afunit;
			if( afunit.formtype == 'serial' ) {				
				afc.startseries = starter;
				afc.endseries = starter + (afunit.qty * interval) - 1;
				starter = afc.endseries + 1;
			}
			else {
				afc.startseries = 1;
				afc.endseries = afunit.qty; 
			}

			afc.dtfiled = afi.parent.dtfiled;
			afc.stubno = stubno++;
			afc.prefix = o.prefix;
			afc.suffix = o.suffix;
			afc.batchno = batchno;
			afc.cost = afi.cost;
			afc.allocation = o.allocation;

			def ref = [:];
			ref.aftxnid = afi.parent.objid;
			ref.aftxnitemid = afi.objid;
			ref.refid = afi.parent.objid;
			ref.refno = afi.parent.controlno;
			ref.refdate = afi.parent.dtfiled;
			ref.reftype = afi.parent.txntype;
			ref.remarks = (ref.reftype == 'PURCHASE_RECEIPT') ? 'RECEIPT OF PURCHASE' : 'BEGIN BALANCE';
			ref.txntype = afi.txntype;
			ref.txndate = txndate;
			ref.issueto = afi.parent.issueto;
			ref.respcenter = afi.parent.respcenter;

			afInvSvc.add( ref, afc );
		} 
		aftxnItem.find([ objid: afi.objid ]).update( [qtyserved: "{qtyserved + :qty}"], [qty: o.qty] );
	}


	//remove batch is only applicable for PURCHASE_RECEIPT,BEGIN_BALANCE AND FORWARD
	@ProxyMethod
	public void removeBatch( def o ) { 
		if( !o.txntype.matches('PURCHASE_RECEIPT|BEGIN_BALANCE')) 
			throw new Exception( "AF Remove Batch Entry is only applicable for PURCHASE_RECEIPT, BEGIN_BALANCE, FORWARD, TRANSFER or RETURN"); 

		def p = [ aftxnitemid: o.aftxnitemid, batchno: o.batchno ];
		afControl.markBatchAsDeleted( p );
		afControl.removeDeletedAfControlDetail( p );
		afControl.reindexBatchno( p );
		afControl.updateAfTxnitemQtyServed( p );
	}	

	@ProxyMethod
	public void editBatch( def o ) { 
		o.each {
			afInvSvc.update( it );
		}
	}	

	//revert batch is used during issuance wherein you need to delete the af control
	@ProxyMethod
	public void revertBatch( o ) { 
		if( !o.aftxnitemid ) throw new Exception("AFTxnService.revertBatch error. aftxnitemid is required ");
		def  p =  [ aftxnitemid: o.aftxnitemid ];		
		afControl.revertAfControlState( p );
		afControlDetail.find( p ).delete();
		afControl.updateAfTxnitemQtyServed( p );
		aftxnItem.find( [objid: o.aftxnitemid ] ).update( [cost: 0 ] );
	}	

	@ProxyMethod
	public void moveBatch( def refitem, def o ) { 
		def txndate = dateSvc.getServerDate();
		def afi = aftxnItem.find([objid: refitem.objid ]).select("objid,qtyserved,qty,txntype,parent.*").first();
		def ref = [:];
		ref.refid = afi.parent.objid;
        ref.reftype = afi.parent.txntype;
        ref.refdate = afi.parent.dtfiled;
        ref.txntype = afi.txntype;
        ref.remarks = afi.txntype;
        ref.txndate = txndate;
        ref.refno = afi.parent.controlno;
        ref.issueto = afi.parent.issueto;
        ref.respcenter = afi.parent.respcenter;
        ref.aftxnid = afi.parent.objid; 
        ref.aftxnitemid = afi.objid;
		o.each {
			def afc = afControl.find( [objid: it.objid ] ).first();
			afInvSvc.add( ref, afc );
		}
		aftxnItem.find([objid: afi.objid]).update( [qtyserved: '{qtyserved + :qty}'], [qty: o.size() ] );
	}	


	//this is called by the main AFRI ebtry screen
	@ProxyMethod
	public void issueBatch( def o ) { 
		def txndate = dateSvc.getServerDate();
		def afi = aftxnItem.find([objid: o.aftxnitemid ]).select("objid,qtyserved,qty,txntype,afid:{item.objid},unit,parent.*").first();
		if( (afi.qtyserved+o.qty) > afi.qty )
			throw new Exception("Qty served must be less than qty requested");

		//lookup allocation based on the resp. center defined in the allocation
		def alloc = null;
		if( afi.parent.respcenter?.objid) {
			alloc = afAlloc.where( "respcenter.objid = :orgid", [orgid: afi.parent.respcenter.objid ] ).first();
		}

		def ref = [:];
		ref.aftxnid = afi.parent.objid;
        ref.aftxnitemid = afi.objid;
		ref.refid = afi.parent.objid;
        ref.reftype = afi.parent.txntype;
        ref.refdate = afi.parent.dtfiled;
        ref.txntype = afi.txntype;
        ref.remarks = afi.txntype;
        ref.txndate = txndate;
        ref.refno = afi.parent.controlno;
        ref.issueto = afi.parent.issueto;
        ref.respcenter = afi.parent.respcenter;

		int qty = o.qty;
		def remarks = afi.txntype;
		def sbuff = new StringBuilder();
		def p = [:];
        p.afid = afi.afid;
        p.unit = afi.unit;
		sbuff.append( "state = 'OPEN' AND afid =:afid AND unit =:unit" );
		if( alloc ) {
			sbuff.append(  " AND allocid =:allocid " );
			p.allocid = alloc.objid;
		}

		def list = afControl.select('objid,startseries,currentseries,endseries').where( sbuff.toString(), p ).orderBy('dtfiled,startseries,stubno').limit( qty ).list();
		if ( !list ) throw new Exception("No available stock for " + p.afid + " " + p.unit);	
		if( list.size() != qty )
			throw new Exception("Not enough stock to issue");

		list.each { itm-> 
			afInvSvc.add( ref, itm );
		}
		
		def zz = [aftxnitemid: o.aftxnitemid]
		afControl.updateAfTxnitemQtyServed( zz );
		afControl.updateAfTxnitemTotals( zz );
	}	

    @ProxyMethod
	public def post( def o ) {
		def c = afControlDetail.find( [refid: o.objid] ).select("c:{COUNT(*)}").groupBy("refid").val();
		if(!c) throw new Exception("There must be at least one qty issued");
		afControl.updateAfControlAfterPosting([aftxnid: o.objid] );
		aftxn.find([ objid: o.objid ]).update([ state: 'POSTED' ]);
	}

}

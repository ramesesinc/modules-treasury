import com.rameses.annotations.*;
import com.rameses.util.*;

class RemittanceService  {

	@DataContext("cashreceipt")
	def cashReceiptEm;

	@DataContext("af_control")
	def afControlEm;

	@DataContext("af_control_detail")
	def afControlDetailEm;

	@DataContext("remittance")
	def remEm;

	@DataContext("remittance_fund")
	def rfEm;

	@DataContext("remittance_af")
	def rafEm;

	@DataContext("checkpayment")
	def checkPmtEm;

	@DataContext("eftpayment")
	def eftPmtEm;

	@Env
	def env;

	@Service("DateService")
	def dateSvc;

	@Service("CashBreakdownSummaryService")
	def cashBreakdownSvc;

	@Service("SequenceService")
	def seqSvc;

	@Service('ControlService') 
	def controlSvc;

	@Service("Var")
	def var;

	@ProxyMethod
	public def getUnremittedAfFundGroupList() {
		def o = [:];
		o.orgid = env.ORGID;
		o.ownerid = env.USERID;
		o.filter = '';
		return remEm.getUnremittedAfFundGroupList(o);		
	}

	@ProxyMethod
	public def getInitialData(def o ) {
		//check first the maximum dates
		o.ownerid = env.USERID;
		o.orgid = env.ORGID;
		//check if there are unremitted receipts that have spread over to the next month

		def filters = [];
		if(o.fundgroup ) {
			filters << ''' fund.remittancefundgroupid = $P{fundgroupid} ''';
			o.fundgroupid = o.fundgroup;
		};
		else {
			filters << " fund.remittancefundgroupid IS NULL "
		}
		if( env.ORGROOT == 1 ) {
			filters << ''' (af.org_objid IS NULL OR af.org_objid = $P{orgid}) ''';
		}
		else {
			filters << ''' af.org_objid = $P{orgid} ''';
		}
		
		o.filter = '';
		if( filters ) {
			o.filter = " AND " + filters.join( " AND ");
		}

		o.receiptfilter = '';
		boolean split_txn = (var.remittance_split_transaction.toString().matches('false|0') ? false : true); 
		if( split_txn ) {
			o.receiptfilter = ''' AND cr.receiptdate < $P{cutoffdate}  ''';
			def YMD = new java.text.SimpleDateFormat('yyyy-MM-dd'); 
			def txndate = dateSvc.getServerDate();
			o.cutoffdate = YMD.parse( YMD.format( dateSvc.add( dateSvc.getMonthEndDate( txndate ), '1d' )) );
		}

		def m = [:];
		m.afList = remEm.getUnremittedAfList(o);
		m.noncashPaymentList = remEm.getUnremittedNonCashPaymentList(o);
		return m;
	}

	/************************************************************************************************************
	* STEPS:
	* 1. create the remittance  
	* 2. insert all af_control_details
	* 3. update remittanceid for cash receipts
	* 4. rebuild the remittance_af
	* 5. update the remittedseries for the af_control for all details where issuedendseries not null
	* 6. update the current detail id per af_control 
	* 7. update remittanceid for check payments and eft payments
	************************************************************************************************************/
	@ProxyMethod
	public def create( def o ) {
		//check if there are open checks first. Do not proceed if there are uncompleted split checks
		def r = [:];
		r.fundgroupid = o.fundgroupid;
		r.controldate = dateSvc.getServerDate();
		r.collector = [objid:env.USERID, name:env.FULLNAME, title: env.JOBTITLE];
		r.controlno = 'TMP-REM-'+ r.collector.objid;
		r.amount = 0;
		r.totalcash = 0;		
		r.totalcheck = 0;
		r.totalcr = 0;
		r.cashbreakdown = [];
		r.state = "DRAFT";
		r.dtposted = dateSvc.getServerDate();
		r = remEm.create( r );

		//create the af_control_details
		o.list.each {
			cashReceiptEm.find( [controlid: it.controlid]).where("series >= :issuedstartseries AND series <= :issuedendseries", it ).update(p);

			//check if there are delegated checks. throw error if there are
			def cnt = cashReceiptEm.find(p).select("count:{COUNT(*)}").where("state = 'DELEGATED' ").val(); 
			if( cnt > 0 ) throw new Exception("There are still delegated receipts not remitted. Please remit this first");

			if( it.issuedendseries ) {
				afControlEm.find([objid: it.controlid]).update( [remittedseries: it.issuedendseries ] );
			}

			def cd = [:];
			cd.putAll( it );
			cd.parent = [objid: it.controlid];
			cd.state = 1;
			cd.refid = r.objid;
			cd.refno = r.controlno;
			cd.refdate = r.controldate;
			cd.reftype = "remittance";
			cd.txntype = "REMITTANCE";
			cd.txndate = r.controldate;
			cd.indexno = 1;
			cd.remarks = "REMITTANCE";
			cd.issuedto = r.collector;
			cd = afControlDetailEm.create( cd );

		}
		
		remEm.updateCheckPaymentRemittanceId( p );
		//check if there are split checks not completed. Do not proceed
		def cnt = checkPmtEm.find( p ).select("cnt:{COUNT(*)}").where( "amount - amtused > 0 ").val();
		if( cnt > 0 ) throw new Exception("There are split checks not completed");

		remEm.updateEftPaymentRemittanceId( p );
		rebuildTotals(r);
	}

	@ProxyMethod
	public def rebuildTotals( def r ) {
		def  p =[remittanceid: r.objid];
		//clean up the remittance fund first
		rfEm.find( p ).delete();
		remEm.insertRemittanceFund( p );
		remEm.updateRemittanceCashTotals( p );
		remEm.updateRemittanceCheckTotals( p );
		remEm.updateRemittanceNonCheckTotals( p );
	}

	@ProxyMethod
	public void acceptForLiquidation( param ) { 

		def rem = remEm.find([ objid: param.objid ]).first(); 
		if ( !rem ) throw new Exception("remittance transaction not found"); 

		if ( rem.collector.objid == env.USERID ) 
			throw new Exception('You are not allowed to liquidate this transaction.'); 

		def m = [ state: 'POSTED']; 
		m.liquidatingofficer = [ objid: env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		remEm.find([ objid: param.objid ]).update( m); 
	}

	@ProxyMethod 
	public void sendBack( param ) { 
		def info = remEm.find([ objid: param.objid ]).select('objid,state').first(); 
		if ( !info ) throw new Exception('Remittance record not found'); 

		if ( info.state.toString().toUpperCase() != 'OPEN' ) {
			throw new Exception('This action is only applicable for transaction with OPEN status'); 
		}

		def m = [ state: 'DRAFT' ]; 
		m.liquidatingofficer = [ objid: null, name: null, title: null ]; 
		remEm.find([ objid: param.objid ]).update( m ); 
	}

	@ProxyMethod 
	public def getReportData( params ) { 
		return params; 
	} 

	@ProxyMethod
	public void updateCollectorSignature( def o ) {
		remEm.find( [objid: o.objid] ).update( [collector: [ signature: o.signature ]] );
	}

	@ProxyMethod
	public void updateApproverSignature( def o ) {
		remEm.find( [objid: o.objid] ).update( [liquidatingofficer: [ signature: o.signature ]] );
	}


	@ProxyMethod
	public def getNoncashPayments(def o ) {
		return remEm.getRemittanceNoncashPayment( [remittanceid: o.objid ]);
	}

	@ProxyMethod 
	public void importData( data ) { 
		if ( !data.objid ) 
			throw new Exception('objid parameter is required in RemittanceService.importData'); 
		if ( !data.cashreceipts ) 
			throw new Exception('cashreceipts parameter is required in RemittanceService.importData'); 

		data.controlno = data.controlno.toString() +'-R';
		remEm.create( data ); 

		def uparam = [ remittanceid: data.objid ]; 
		data.cashreceipts.each{ 
			cashReceiptEm.find([ objid: it ]).update( uparam ); 
		} 

		if ( data.vertype.toString() == 'v255' ) {
			data.remittancefunds.each{
				it.controlno = it.controlno.toString() +'-R'; 
				it.remittance = [objid: it.remittanceid];
				rfEm.create( it );  
			}

		} else {
			def mparam = [ remittanceid: data.objid ]; 
			def remfunds = remEm.getBuildRemittanceFunds( mparam ); 
			remfunds.each{
				it.objid = (it.remittanceid + it.fund.objid); 
				it.controlno = (it.controlno +'-'+ it.fund.code); 
				it.remittance = [objid: it.remittanceid];
				it.cashbreakdown = []; 
				rfEm.create( it ); 
			} 
		}
	} 
} 
